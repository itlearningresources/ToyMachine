//   0x00 halt                              haltflag = true                         
//   0x01 add                               reg[d] = reg[s] + reg[t]                
//   0x02 subtract                          reg[d] = reg[s] - reg[t]                
//   0x03 bitwise and                       reg[d] = reg[s] & reg[t]                
//   0x04 bitwise or                        reg[d] = reg[s] ^ reg[t]                
//   0x05 shift left                        reg[d] = reg[s] << reg[t]               
//   0x06 shift right                       reg[d] = reg[s] >> reg[t]               
//   0x07 load address                      reg[d] = addr                           
//   0x08 load                              reg[d] = mem[addr]                      
//   0x09 store                             mem[addr] = reg[d]                      
//   0x0A load indirect                     reg[d] = mem[reg[t] & 0xFFFF]           
//   0x0B store indirect                    mem[reg[t] & 0x0FFFF] = reg[d]          
//   0x0C branch if zero                    if ((short) reg[d] == 0) pc = addr      
//   0x0D branch if pos                     if ((short) reg[d] >  0) pc = addr      
//   0x0E jump indirect                     pc = reg[d]                             
//   0x0F jump and link                     reg[d] = pc; pc = addr                  
//   0x10 push address                      push addr                               
//   0x11 push register                     push reg[d]                             
//   0x12 pop to register                   pop to reg[d]                           
//   0x13 increment register                reg[d]++                                
//   0x14 decrement register                reg[d]--                                
//   0x15 shift reg left                    reg[d] = reg[d] << 1                    
//   0x16 shift reg right                   reg[d] = reg[d] >> 1                    
//   0x17 push pc and link                  push pc and pc = addr                   
//   0x18 jump                              pc = addr                               
//   0x19 pop and link                      return                                  
//   0x20 NOP                               NOP                                     
//   0x21 Load Addr Reg                     reg[ADRR] = addr                        
//   0x22 Inc Addr Reg                      reg[ADRR]++                             
//   0x23 Store Reg indirect Addr Reg       mem[reg[d]]= reg[ADRR]                  
//   0x24 Push This                         push this addr                          
//   0x50 reg char out                      reg[d] char out                         
//   0x51 mem char out                      mem[addr] char out                      
//   0x52 string 10 16b                     string out 16b                          
//   0x53 string out 8b                     string out 8b                           
